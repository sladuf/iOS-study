# 🍎 Swift 언어

## 0. 변수와 상수

> ### 💁🏻‍♂️ 0-1 : 변수와 상수에 대해서 설명해 주세요


1. 변수는 선언 이후에도 값을 계속해서 변경할 수 있지만, 상수는 선언 이후에 값을 변경할 수 없습니다
2. Swift에서 변수는 var 상수는 let으로 선언합니다
3. var는 참조하고 있는 주소값을 바꿀 수 있지만, let은 참조하는 주소값을 바꿀 수 없다는 의미를 가지기도 합니다

> **💁🏻‍♂️💁🏻‍♂️ 참조하는 주소값을 바꿀 수 없다는게 정확히 어떤 의미인가요?**

```swift
class Some {
    var num : Int
    
    init(num: Int) {
        self.num = num
    }
}

let a = Some(num: 10)
let b = Some(num: 20)
var c = Some(num: 30)
```

다음과 같은 인스턴스가 있을 때 상수는 값을 변경할 수 없기 때문에 아래와 같은 행위를 할 수 없습니다

```swift
a = b
a = c
b = a
b = c
```

class는 참조타입이기 때문에 각 변수와 상수에는 주소값(==포인터)이 들어있습니다.

즉, 상수로 선언했기 때문에 **참조 주소에 대한 포인터를 바꿀 수 없다는 의미**로 해석됩니다

아래와 같은 행위는 참조 주소값이 바뀌지 않기 때문에 가능합니다

```swift
a.num = b.num
b.num = c.num
```

그리고 아래와 같은 행위는 c가 참조하고 있는 a가 참조하는 주소값으로 변경합니다

```swift
c = a
```

> ### 💁🏻‍♂️ 0-2 : 타입추론에 대해서 설명해 주세요

1. 변수와 상수는 타입을 명시할 수도 있고 생략할 수도 있습니다.
2. 타입을 생략하는경우 컴파일러가 타입 추론 과정을 거쳐 타입을 지정합니다
3. 타입을 생략하는 경우 타입추론 과정을 거쳐야 하기 때문에 타입을 명시하는 것보다 컴파일에 더 오랜 시간이 걸릴 수 있습니다


## 1. Class / Struct
> ### 💁🏻‍♂️ 1-1 : Class 와 Struct의 차이를 설명해주세요

1. struct는 **value type**이고 class는 **reference type**입니다
2. 그래서 class는 ARC를 통해 메모리를 관리합니다
3. class는 상속이 가능하지만 struct는 상속할 수 없습니다

- 공통점
1. 프로퍼티와 메서드를 정의할 수 있습니다
2. 이니셜라이저를 정의하여 초기화될 때의 상태를 지정할 수 있습니다
3. extension을 통해 확장할 수 있습니다
4. 프로토콜을 준수할 수 있습니다

```
값타입과 참조타입의 가장 큰 차이는 '무엇이 전달되느냐' 입니다.
(💡 전달 : 함수의 파라미터나 새로운 변수에 할당하는 것)
값타입을 전달할 때에는 메모리에 전달인자를 위한 인스턴스가 새로 생성됩니다. 즉, 전달되는 값이 복사 됩니다.
참조타입을 전달할 때에는 인스턴스의 참조(주소)가 전달됩니다.
```

> **💁🏻‍♂️💁🏻‍♂️ 언제 class를 사용하고, 언제 struct를 사용하나요?**

Apple 가이드라인에서 다음 조건 중 하나 이상에 해당한다면 **구조체를 사용하는 것을 권장**합니다
- 연관된 간단한 값의 집합을 캡슐화하는 목적일 때
- 프로퍼티가 값 타입이고 참조보다 복사하는 것이 합당할 때
- 상속할 필요가 없을 때

즉, 상속 관계를 필요로 하거나 객체의 값이 계속 가공되는경우에는 class가 더 유리합니다

> ### 💁🏻‍♂️ 1-2 : Swift의 복사 방법에 대해서 설명해 주세요

1. swift는 **COW**방식을 사용해서 값타입을 복사합니다
2. COW는 원본과 복사본 중 수정되기 전까지는 복사를 하지 않고 **원본 리소스를 공유**하다가, 둘 중 하나에서 수정이 일어나는 경우 복사하는 작업을 합니다
3. 그래서 COW를 사용하는 타입에서 복사 후 첫번째 수정이 일어나는 경우에는 COW에 의해 약간의 **오버헤드**를 발생시킵니다
4. 모든 value type에서 사용되는 것이 아니라 **collection type**을 복사할 때 사용됩니다.

> **💁🏻‍♂️💁🏻‍♂️ 오버헤드가 발생하는데 COW를 왜 사용하는걸까요?**

swift의 COW는 시간과 공간 중에 공간의 효율을 선택했다고 볼 수 있습니다.

실제로 값의 복사만 일어나고 수정이 일어나지 않는 경우도 있기 때문에 불필요한 복사를 줄여 메모리를 절약할 수 있습니다.

```
📌 리소스 공유
COW의 리소스 공유와 class의 참조는 조금 다른 경향을 가집니다
class 인스턴스를 참조할 때에는 서로 다른 메모리에 '같은 인스턴스의 주소값'을 참조하고 있습니다
COW의 리소스 공유는 동일한 메모리를 가르키고 있습니다
예를들어 b가 a를 복사한 경우에는 수정이 일어나기 전까지는 b는 메모리를 할당받지 않고 a와 같은 메모리를 사용합니다
다시 말하면,
class의 a와 b는 서로 다른 메모리에 할당 되지만 그 메모리에는 같은 '주소값'이 담겨 있습니다
collection type의 a와 b는 서로 같은 메모리를 사용하고 있고 그 메모리에 있는 값은 '데이터'입니다
그리고 데이터가 변경되면 b는 메모리를 할당 받고 같은 데이터를 복사한 후에 데이터가 변경됩니다
(참고 : https://nsios.tistory.com/56)

📌 collection type
Array, Set, Dictionary
```
- [https://babbab2.tistory.com/18](https://babbab2.tistory.com/18)

- [https://forestjae.tistory.com/30](https://forestjae.tistory.com/30)

> ### 💁🏻‍♂️ 1-3 : class의 성능을 향상 시킬 수 있는 방법을 설명해주세요

- **final**

1. 상속되지 않는 클래스에 **final**을 붙이면 메소드가 Static Dispatch를 사용하기 때문에 오버헤드가 줄어 성능이 향상 됩니다
2. 클래스는 상속이 가능하기 때문에 메소드가 오버라이딩 될 가능성이 있어 Dynamic Dispatch를 사용합니다
3. 하지만 final 키워드를 붙이면 클래스의 상속이 불가능하여 메소드의 오버라이딩도 불가능해져 Static Dispatch를 사용합니다
4. **Dynamic Dispatch**는 런타임시 실행할 메소드를 결정하고, **Static Dispatch**는 컴파일 타임에 결정하기 때문에 오버헤드를 줄일 수 있습니다


```
📌 Dynamic Dispatch
- class는 기본적으로 상속이 가능하기 때문에 상위 클래스와 하위 클래스 중 어디를 참조해야할지를 런타임 시점에 결정합니다
- 런타임 과정에서 vTable에서 함수를 찾아 메모리 주소를 '읽고' 그 주소로 '점프' 해야 하기 때문에 성능상 손해가 발생합니다
📌 vTable
- 정의 : 디스패치를 지원하기 위해 프로그래밍 언어에서 사용하는 메커니즘
- 클래스 마다 가지고 있는 가상테이블을 말하며 메서드들의 포인터 값을 가지고 있습니다
- 하위 클래스는 상위 클래스의 vTable 복사본을 가지고, 오버라이딩하는 경우에는 오버라이딩 한 메서드를 가리키는 함수 포인터로 저장됩니다
```


> **💁🏻‍♂️💁🏻‍♂️ Dispatch가 뭔데요?**

Dispatch는 어떤 메서드를 호출할 것인지를 결정하여, 그것을 실행하는 메커니즘입니다. Static, Dynamic 두 가지 방식이 있습니다

Static Dispatch는 호출할 함수를 컴파일 타임에 결정합니다. Dynamic Dispatch는 호출할 함수를 런타임에 결정합니다

기본적으로 값타입은 Static Dispatch를 사용하며, 참조타입에서 어떤 Dispatch를 선택하는지는 오버라이딩 가능성에 따라 결정됩니다

그래서 final 키워드를 붙이면 Static Dispatch를 사용하게 되는것 입니다



- **WMO**

1. Whole Module Optimization을 사용하면 성능향상을 기대할 수 있습니다
2. WMO는 모듈 전체를 하나의 덩어리로 컴파일하여 internal level에 대해서 오버라이딩 되지 않는 경우 내부적으로 final을 붙여서 컴파일 합니다
3. 이는 개발자가 발견하지 못한 상속되지 않는 클래스에 대해 Dynamic Dispatch의 사용을 줄여 성능 향상을 기대할 수 있습니다


```
🤔 WMO안하면 왜 자동으로 final을 못붙여주는걸까?
- 기본적으로 swift는 파일을 하나씩 컴파일 하기 때문에 서로 다른 파일에서 클래스를 상속했는지 컴파일 타임에 알 수 없어서 final을 붙일 수 없습니다
```

- [https://babbab2.tistory.com/145?category=828998](https://babbab2.tistory.com/145?category=828998)

> ### 💁🏻‍♂️ 1-4 : swift의 타입캐스팅에 대해서 설명해주세요

1. swift의 타입캐스팅은 타입을 바꾸는 것이 아닌 **사용 범위를 전환**하여 다른 타입처럼 행세할 수 있도록 합니다
2. 업캐스팅은 하위클래스가 상위클래스 타입으로 전환하는 것이고, 다운캐스팅은 상위클래스가 하위클래스 타입으로 전환하는 것입니다
3. 업캐스팅을 하는 경우에는 무조건 전환이 가능하므로 as를 사용합니다
4. 다운캐스팅을 하는 경우에는 실패 가능성이 있으므로 **as?** 또는 **as!** 를 사용합니다. 둘 다 런타임에 캐스팅합니다
5. as?는 옵셔널이 반환됩니다. as!는 옵셔널이 강제 추출되므로 다운캐스팅이 불가능한 경우에는 런타임 에러가 발생할 수 있습니다

> **💁🏻‍♂️💁🏻‍♂️ 캐스팅하면 타입이 바뀌지 않나요?**

1. 예를들어 class Person {}, class Student: Person {}를 살펴보겠습니다
2. let student = Student() as Persen을 하는 경우에는 업캐스팅되어 Student에서 새로 만든 프로퍼티와 메서드를 사용하는 것이 불가능합니다
3. 하지만 type(of: student)는 여전히 Student입니다. 즉, type이 바뀌는 것이 아니라 범위를 전환하는 것입니다




## 2. 접근제어자


> ### 💁🏻‍♂️ 2-1 : 접근 제어자의 종류엔 어떤게 있는지 설명해주세요

1. 접근제어는 접근수준 키워드를 통해 구현할 수 있습니다. 접근수준 키워드는 open, public, internal, fileprivate, private 다섯 가지가 있습니다.
2. 키워드 중에서 open은 클래스와 클래스의 멤버에서만 사용할 수 있습니다.
3. 접근 수준에는 규칙이 있는데 상위요소보다 하위요소가 더 높은 접근 수준을 가질 수 없습니다.


> ### 💁🏻‍♂️ 2-2 : open과 public 키워드의 차이를 설명해보세요

1. open과 public은 외부 모듈까지 접근을 허용한다는 공통점이 있습니다
2. open은 모듈 외부에서 상속하거나 오버라이딩 할 수 있습니다. 단, 클래스와 클래스 멤버에서만 사용할 수 있습니다
3. public은 모듈 외부에서 상속과 오버라이딩이 불가능합니다. 같은 모듈 내에서는 상속과 오버라이딩을 할 수 있습니다

> ### 💁🏻‍♂️ 2-3 : fileprivate과 private 키워드의 차이를 설명해보세요

fileprivate은 그 요소가 구현된 소스파일 내부에서 사용할 수 있지만, private은 기능을 정의하고 구현한 범위 내에서만 사용할 수 있습니다.

> **💁🏻‍♂️💁🏻‍♂️ class나 struct를 private으로 만들면 어떻게 될까요?**

아래의 코드는 정상 동작합니다.
```swift
private class A {
    func someFunction(){
        print("This is function")
    }
}

private let a = A()
a.someFunction()
```
추측하건데 구현체 자체에 private을 붙이는 경우에는 구현체의 상위인 '파일'을 구현체로 인식하는 것 같습니다.

그래서 동일한 파일 내에서는 A 클래스를 사용할 수 있습니다.

즉, fileprivate 처럼 동작합니다.

그 근거로 상위 접근 수준인 fileprivate 클래스내에 private 클래스의 인스턴스를 만들 수 있습니다.

```swift
fileprivate let a = A()
a.someFunction()
```

## 3. 이니셜라이저
> ### 💁🏻‍♂️ 3-1 : Convenience init에 대해 설명해주세요

1. 편의 이니셜라이저는 초기화를 좀 더 쉽게 할 수 있도록 도와주는 역할을 합니다
2. 편의 이니셜라이저는 꼭!!! 지정 이니셜라이저를 호출해야합니다 -> self.init()

> **💁🏻‍♂️💁🏻‍♂️ 정말 편의이니셜라이저는 꼭!!! 지정 이니셜라이저를 호출해야할까요?**


편의 이니셜라이저는 여러개 존재할 수 있습니다. 편의 init이 다른 편의 init을 호출할 수도 있습니다

하지만 최종적으로 호출되는 편의 이니셜라이저는 꼭! 지정 이니셜라이저를 호출해야 합니다

그렇기 때문에 결론적으로 편의 이니셜라이저를 호출하면 마지막에 지정 이니셜라이저를 호출하게 됩니다

> **💁🏻‍♂️💁🏻‍♂️ 편의 이니셜라이저 꼭 써야 하나요?**

아니요! 편의 이니셜라이저는 옵션입니다

차이점이 있다면 지정 이니셜라이저는 self.init을 호출할 수 없다는 것입니다

어떤 클래스에 다음과 같은 저장 프로퍼티와 지정 이니셜라이저가 있을때

```swift
var a : Int
var b : Int
var c : Int

init(a: Int, b: Int, c: Int) {
    self.a = a
    self.b = b
    self.c = c
}
```

아래의 두 이니셜라이저는 똑같이 동작합니다. 그렇기 때문에 아래의 두 이니셜라이저는 동시에 선언할 수 없습니다

```swift
init(a: Int) {
    self.a = a
    self.b = 0
    self.c = 0
}

convenience init (a: Int){
    self.init(a: a, b: 0, c: 0)
}
```

- https://zeddios.tistory.com/141

> ### 💁🏻‍♂️ 3-2 : required init에 대해서 설명해 주세요

1. required init은 상속받은 모든 하위 클래스들이 재정의 해야하는 이니셜라이저 입니다
3. 하위 클래스가 required init을 구현해야하는 강제성이 있으므로 override 키워드를 붙이지 않습니다
4. 하위 클래스에서 아무런 이니셜라이저도 구현하지 않는 경우에는 상위 클래스의 이니셜라이저가 자동상속 되므로 required init을 구현하지 않아도 됩니다.
5. 단, 하위클래스에서 어떠한 종류의 이니셜라이저라도 구현하는 경우에는 자동상속 되지 않으므로 required init을 함께 구현해야 합니다


```
⭐️ convenience init, required init은 **class 이니셜라이저** 입니다!
```

> ### 💁🏻‍♂️ 3-3 : class의 초기화 진행 과정에 대해서 설명해 주세요

swift의 클래스 초기화는 2단계를 거칩니다

- **1단계 : 클래스에 정의한 저장 프로퍼티에 초깃값이 할당됩니다**

- **2단계 : 모든 저장 프로퍼티의 초기 상태가 결정되면 사용자 정의할 기회를 가집니다**

초기화 단계는 프로퍼티를 초기화하기전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있도록 합니다

컴파일러는 2단계 초기화를 오류 없이 처리하기 위해 **네 가지 safety-checks**를 합니다

1. 자식클래스의 init이 부모클래스의 init을 호출하기 전에 자신의 프로퍼티를 모두 초기화 했는지 확인합니다

```swift
class Perents {
    var home : String
    var firstName : String
    
    init(home: String, firstName: String) {
        self.home = home
        self.firstName = firstName
    }

}

class Child : Perents {
    var lastName : String
    var age : Int
    
❌
    init(lastName: String, age: Int) {
        super.init(home: "한강뷰", firstName: "김")
        self.lastName = lastName
        self.age = age
    }

⭕️
    init(lastName: String, age: Int) {
        self.lastName = lastName
        self.age = age
        super.init(home: "한강뷰", firstName: "김")
    }
}
```

2. 자식클래스의 init은 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 init을 호출해야합니다

```swift
init(lastName: String, age: Int) {
        self.lastName = lastName
        self.age = age

        self.home = "강남" ❌
        super.init(home: "한강뷰", firstName: "김")
        self.home = "강남" ⭕️
    }
```

3. 편의 이니셜라이저는 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 init을 호출해야 합니다

```swift
convenience init(age: Int){
    self.age = 20 ❌
    self.home = "한강뷰" ❌
    self.init(lastName: "홍길동", age: age)
    self.age = 20 ⭕️
    self.home = "한강뷰" ⭕️
}
```

4. 초기화 1단계를 마치기 전까지 이니셜라이저는 메서드를 호출하거나 프로퍼티 값을 읽을 수 없습니다.
    
    ```swift
    init(lastName: String, age: Int) {
        sayHello() ❌ //프로퍼티에 값 할당 전이므로 1단계 전임
        self.lastName = lastName
        self.age = age
        super.init(home: "한강뷰", firstName: "김")
        sayHello() ⭕️ //나와 상위에 있는 모든 프로퍼티에 값을 할당 했으므로 1단계 마침
    }
    
    func sayHello(){
        print("hello")
    }
    ```


> ### 💁🏻‍♂️ 3-4 : deinit은 언제 사용할까요?
1. 클래스 인스턴스가 메모리에서 해제될 때 클래스 인스턴스와 관련하여 정리하는 작업이 필요한 경우에 사용합니다
2. deinit 키워드를 사용하여 구현하면 메모리에서 해제되는 시점에 자동으로 호출됩니다
3. 인스턴스가 해제될 때 가지고 있던 데이터를 어딘가에 보내주거나 저장해야 하는 경우, 인스턴스의 메모리 해제를 확인하고 싶은 경우에 사용할 수 있습니다

## 4. Extension
> ### 💁🏻‍♂️ 4-1 : Extension에 대해 설명하시오.
1. extension은 클래스, 구조체, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있습니다
2. 기존에 있는 프로퍼티와 메서드를 **재정의 할 수 없습니다**
3. 프로퍼티는 저장 프로퍼티를 제외한 **연산 프로퍼티만** 정의할 수 있습니다. 메서드는 자유롭게 정의할 수 있습니다
4. deinit은 정의할 수 없고 init은 class의 경우에는 편의 이니셜라이저만 추가할 수 있습니다. **값타입은 경우에는 따라 지정 이니셜라이저를 추가할 수 있습니다.**

```
📌 값타입에서 extension을 통해 지정 이니셜라이저를 추가할 수 있는 경우
- 모든 저장 프로퍼티에 기본값이 있어야 합니다
- 타입내에 기본 이니셜라이저와 멤버와이즈 이니셜라이저 외에 사용자 정의 이니셜라이저가 없어야 합니다
```

## 5, 데이터타입

> ### 💁🏻‍♂️ 5-1 : Optional에 대해서 설명해주세요

옵셔널은 값이 있을 수도, 없을 수도 있음을 나타내는 스위프트의 특징 중 하나로 안전성을 강조합니다

```
📌 옵셔널을 사용하는 방법
- 데이터 타입 뒤에 **물음표**를 붙여서 사용할 수 있습니다 (var optinal : String?)
- **Optional**<Wrapped>을 통해 사용할 수 있습니다 (var optional : Optional<String>)
```


> **💁🏻‍♂️💁🏻‍♂️ 옵셔널을 사용하는 이유가 뭐죠?**

1. 스위프트에서 옵셔널이 아닌 변수나 상수에는 값이 없음을 의미하는 nil을 할당할 수 없습니다
2. 옵셔널을 사용함으로써 변수나 상수가 값이 없을 수도 있음을 직관적으로 받아들일 수 있습니다
3. 예로 함수에 전달되는 매개변수 중 굳이 넘기지 않아도 되는 경우에는 옵셔널로 정의하여 값이 없어도 괜찮음을 직관적으로 보여줄 수 있습니다

> **💁🏻‍♂️💁🏻‍♂️ 옵셔널은 어떻게 구현되어 있나요?**

1. 옵셔널은 **제네릭**이 적용된 **열거형**으로 구현되어 있습니다
2. @frozen 키워드는 type 변경을 제한 하기 때문에 옵셔널에 **case가 추가 되지 않음**을 보장합니다

```swift
@frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
    case none
    case some(Wrapped)

		/// 중략
}
```

> **💁🏻‍♂️💁🏻‍♂️ 옵셔널을 일반 데이터 타입으로 사용하려면 어떻게 해야하나요?**

1. 스위프트에서 제공하는 옵셔널 바인딩을 사용하여 안전하게 옵셔널을 벗길 수 있습니다
2. if let 구문과 guard let 구문을 사용하여 옵셔널을 벗긴 값을 사용할 수 있습니다
3. 옵셔널 변수뒤에 **느낌표**를 붙여  강제 추출 할 수도 있습니다. 하지만, nil인 경우 런타임 에러가 나기 때문에 값이 있음을 확신할 수 있는 경우에만 사용해야 합니다

```
📌 옵셔널 바인딩 값의 사용
- if let은 if문 내부에서만 옵셔널 바인딩한 값을 사용할 수 있습니다
- guard let은 옵셔널 바인딩이 성공 하면 그 이후의 코드에서 변수를 자유롭게 사용할 수 있습니다

📌 ExpressibleByNilLiteral
- 이 프로토콜은 nil로 해당 타입을 초기화 할 수 있는 자격요건을 명시합니다
```

> ### 💁🏻‍♂️ 5-2 : enum에 대해서 설명해주세요

1. 열거형은 연관된 항목들을 묶어서 표현할 수 있는 데이터 타입 입니다
2. 열거형은 개발자가 정의한 항목 값 이외에는 추가하거나 수정이 불가능합니다
3. 열거형을 사용할 때에는 점(.)을 통해서 case에 접근할 수 있습니다
4. 열거형을 사용하면 오타를 줄여줄 수 있을 뿐만 아니라 코드의 가독성을 향상 시킬 수 있습니다
5. **원시값**이나 **연관값**을 사용하여 디테일한 값을 저장할 수 있습니다


> **💁🏻‍♂️💁🏻‍♂️ enum의 원시값에 대해서 자세히 설명해 주세요**

1. case에 원시값을 지정해 줄 수 있는데, enum을 선언할 때 이름 옆에 원시값의 type을 명시해주어야 합니다
2. 원시값의 type은 Number, Character, String 세가지만 가능합니다
3. 원시값은 type에 따라 자동으로 생성되는 경우도 있고, 모두 명시해주어야 하는 경우도 있습니다
4. 원시값은 **rawValue**라고 하는 속성을 통해 접근할 수 있습니다

```swift
enum Num : Int{
    case zero
    case one = 10
    case two
    case three
}

print(Num.two.rawValue) //11
```

```
🤔 원시값은 언제 자동 생성될까?
- 정수값이 들어 있는 경우 위에 선언된 값에서 +1 증가된 값을 생성합니다
- String은 원시값을 지정하지 않은 경우 case이름과 동일한 rawValue를 생성합니다
(detail : https://babbab2.tistory.com/116)
```


> **💁🏻‍♂️💁🏻‍♂️ 열거형의 연관값에 대해서 자세히 설명해 주세요**

1. 연관값은 case에 조금더 상세한 정보를 가질 수 있으며, 튜플 형태로 원하는 타입을 명시해서 사용할 수 있습니다
2. 연관값은 모든 case가 가져가 하는 것은 아니며 옵션입니다

```swift
enum Apple {
    case iPhone(model: String)
    case iPad
    case mackBook
}

var apple = Apple.iPhone(model: "14pro")

switch apple {
case .iPhone(model: "14pro"):
    print("최신형 iPhone")
case .iPhone(model: let model):
    print(model)
case .iPad:
    print("iPad")
case .mackBook:
    print("mackBook")
}

// 최신형 iPhone
```

> ### 💁🏻‍♂️ 5-3 : Swift의 컬렉션 타입에 대해서 설명해 주세요

1. 컬렉션 타입은 많은 양의 데이터를 묶어서 저장하고 관리할 수 있습니다. Swift의 컬렉션 타입에는 Array, Dictionary, Set이 있습니다
2. 배열은 같은 타입의 데이터를 **순서대로** 저장하는 컬렉션 타입입니다. 다른 위치에 같은 값이 존재할 수 있습니다. Array는 순서가 있기 때문에 원하는 위치에 데이터를 추가, 수정, 삭제 할 수 있습니다.
3. 딕셔너리는 순서 없이 데이터를 **key-value** 형태로 저장하는 컬렉션 타입입니다. 딕셔너리의 key값은 **Hashable** 프로토콜을 따라야하며 중복될 수 없습니다.
4. 세트는 같은 타입의 데이터를 **순서없이** 하나의 묶음으로 저장하는 컬렉션 타입입니다. 세트 내의 값은 모두 유일하며 **중복된 값을 가질 수 없습니다**. Set는 **Hashable** 프로토콜을 따르는 데이터 타입만 사용 가능합니다.

```
📌 Swift의 Array는 버퍼입니다.
필요에 따라 자동으로 버퍼의 크기를 조절해주므로 요소의 삽입 및 삭제가 자유롭습니다.

📌 Hashable 프로토콜
스위프트의 기본 데이터 타입은 모두 Hashable 프로토콜을 채택합니다.
```

> **💁🏻‍♂️💁🏻‍♂️ Array보다 Set을 사용하는게 더 좋을 때는 언제일까요?**

1. 순서가 중요하지 않고 데이터를 중복없이 고유하게 관리할 때는 Set을 사용하는 것이 더 좋습니다.
2. Set은 **삽입, 삭제, 조회를 모두 O(1)** 에 할 수 있기 때문에 순서가 중요하지 않으면서 삭제와 삽입이 빈번할 때도 Set이 더 좋을 수 있습니다.


> ### 💁🏻‍♂️ 5-4 : Any와 AnyObject에 대해서 설명해주세요

1. Any는 모든 데이터 타입을 사용할 수 있다는 의미입니다. 변수가 Any 타입으로 지정되어 있다면 모든 데이터 타입을 할당할 수 있습니다
2. AnyObject는 Any보다 조금 한정된 의미로 **클래스의 인스턴스**만 할당할 수 있습니다
3. Any로 선언된 변수의 값을 사용하기 위해서는 매번 타입 확인 및 변환을 해주어야 하기 때문에 번거롭습니다
4. Swift는 타입에 엄격한 언어라는 특성이 있어 Any와 AnyObject의 사용을 권장하지 않습니다



## 6. 클로저
> ### 💁🏻‍♂️ 6-1 : Closure에 대해 설명해 주세요

1. 클로저는 어떤 기능을 하는 코드들을 블록으로 모아놓은 객체입니다.스위프트에서 함수형 패러다임으로 구현할 때 매우 중요한 역할을 합니다.
2. 클로저는 class와 같은 **참조 타입**입니다.

> ### 💁🏻‍♂️ 6-2 : Closure 의 값 캡처에 대해 설명해 주세요

1. 클로저는 자신이 정의된 위치에서 외부에 있는 값들을 캡쳐할 수 있습니다. 클로저는 값의 타입과 관계 없이 값을 캡쳐할 때 ****참조**** 합니다.
2. 만약 **value 타입**을 참조하지 않고 복사하고 싶은 경우에는 Closure List를 사용해서 클로저를 선언할 당시의 값을 **상수**로 캡쳐할 수 있습니다. 상수로 캡쳐되기 때문에 클로저 내부에서 값을 바꿀 수 없습니다.

- capture list

```swift
var string = "hello"
let closure = { [string] in
	string = "hi" // ❌error
	print(string)
}
```
> **💁🏻‍♂️💁🏻‍♂️ 참조하면 메모리 이슈가 있을거 같은데요?**

클로저는 참조타입의 값을 캡쳐할 때 **strong**으로 캡쳐하기 때문에 참조하는 인스턴스의 RC값이 증가합니다.

클래스안에서 클로저를 사용하고, 그 클로저가 클래스의 값을 self로 참조하는 경우에는 해당 인스턴스를 nil처리 하더라도 클로저에 의해 메모리에서 해제되지 않는 **강한 순환 참조** 문제가 발생할 수 있습니다.

클로저의 강한 순환 참조는 **capture list를 사용하여 self를 weak으로 캡쳐**하여 RC값을 증가시키지 않도록 할 수 있습니다.

```
📌 강한 순환 참조
인스턴스가 서로를 강한 참조하는 경우를 강한 순환 참조라고 합니다.
참조 타입 인스턴스 A와 B가 있고, 각각의 인스턴스가 프로퍼티로 B와 A를 가지고 있는 경우를 예로 들겠습니다.
이 경우에는 A,B에 모두 nil을 선언 하더라도 메모리에서 해제되지 않습니다. 서로의 인스턴스를 참조하여 RC값이 남아있기 때문입니다.
하지만 더이상 A,B를 접근할 수 있는 방법이 없어 사용할 수 없습니다. A,B모두 메모리에 존재하지만 사용할 수 없는 상태가 되어 메모리 누수가 발생합니다.
이러한 문제를 강한 순환 참조 문제라고 합니다.
```
> **💁🏻‍♂️💁🏻‍♂️ self를 weak 말고 unowned로 캡쳐하면 안되나요?**

만약 클래스 내에서 클로저가 unowned로 self를 캡쳐하는 경우에는 시점 차이로 인해 해당 인스턴스가 nil이 할당 된 후에도 클로저의 작업이 실행되어야 하는 상황이 생길 수 있습니다.

unowned는 존재하지 않는 메모리 주소를 계속해서 참조하기 때문에 런타임 에러가 발생할 수 있습니다. 그래서 메모리에서 해제된 경우 nil을 반환하는 weak 사용을 권장합니다.

> **💁🏻‍♂️💁🏻‍♂️ Name Closure도 값을 캡쳐하나요?**

Name Closure인 경우에는 어디에 위치 하냐에 따라 다릅니다.

전역 함수는 어떠한 값도 캡쳐하지 않습니다.

중첩 함수는 자신을 포함하고 있는 함수의 값을 reference capture 합니다.

- https://babbab2.tistory.com/83

> ### 💁🏻‍♂️ 6-3 : Trailing Closure에 대해서 설명해 주세요

1. 함수 파라미터의 제일 마지막 요소가 클로저 일 때 소괄호 밖에서 클로저를 선언할 수 있는데 이를 후행 클로저라고 합니다.
2. 만약 파라미터에 클로저가 여러개 있는 경우, 다중 후행 클로저 문법을 사용할 수 있습니다. 이 경우에는 소괄호 밖에서 중괄호를 열고 닫으며 클로저를 표현합니다.
3. 클로저의 양이 길어지는 경우 후행 클로저를 사용하면 가독성을 높일 수 있습니다. Xcode에서도 후행 클로저의 사용을 권장하고 있습니다. (자동 변환됨)

> ### 💁🏻‍♂️ 6-4 : Escpaing Closure에 대해 설명해 주세요

1. 함수 파라미터로 전달한 클로저가 함수 종료 이후에 호출될 때 탈출 클로저를 사용해야 합니다.
2. 탈출 클로저를 사용해야 하는 경우는 함수 외부에서 클로저를 저장하거나 사용하는 경우 입니다.
3. 주로 비동기 작업을 할 때 탈출 클로저를 많이 사용합니다. 비동기 작업을 실행하는 함수는 비동기 작업으로 함수가 종료되고 호출해야 하는 클로저를 탈출 클로저로 받습니다.
4. 탈출 클로저는 클로저 앞에 **@escaping** 키워드를 사용하여 작성합니다.

> ### 💁🏻‍♂️ 6-5 : Function과 Closure의 차이점을 말해보세요

1. 클로저는 다양한 형태를 가질 수 있는데, 함수는 클로저의 형태 중 하나입니다. 즉, 함수는 클로저에 속합니다.
2. 하지만 주로 이름이 있는 클로저를 함수라고 표현하고, 익명 클로저를 클로저라고 표현합니다.

- https://babbab2.tistory.com/81

## 7. ARC

### 💁🏻‍♂️ 7-1 : ARC에 대해서 설명해 주세요

1. ARC는 swift에서 참조타입의 메모리를 자동으로 관리해주는 방식입니다.
2. ARC는 더이상 참조되지 않는 클래스의 인스턴스를 메모리에서 자동으로 해제합니다.
3. 메모리에서 인스턴스를 언제 해제할지에 대한 여부는 인스턴스의 RC값을 통해 결정합니다.

**💁🏻‍♂️💁🏻‍♂️ 언제 RC값이 증가하고 언제 감소하나요?**

1. RC값은 인스턴스를 생성하거나, 복사하거나 참조할 때 증가합니다.
2. 함수내에서 인스턴스의 사용이 끝나거나 인스턴스를 참조하는 변수에 nil을 할당하게 되면 RC값이 감소합니다.

### 💁🏻‍♂️ 7-2 : 참조는 어떤게 있나요?

1. 참조의 종류는 strong, weak, unowned 세 가지 입니다.
2. strong은 강한 참조를 하여 RC값을 +1 증가 시키는 키워드 입니다.
3. weak과 unowned는 RC값을 증가시키지 않고 참조할 수 있는 키워드 입니다.

```
💡 strong은 강한참조, weak은 약한참조, unowned는 미소유참조 라고 합니다.
```

**💁🏻‍♂️💁🏻‍♂️ weak과 unowned은 어떤 차이가 있나요?**

1. weak은 참조하고 있는 인스턴스가 메모리에서 해제되면 **nil**을 가지게 됩니다.
2. unowned는 참조하고 있는 인스턴스가 메모리에서 해제되더라도 그 인스턴스가 있던 메모리 주소를 **계속해서 참조**합니다. 즉 비어있는 공간을 참조하는 것입니다.
3. 객체를 참조하는 방식에서의 차이도 있습니다. unowned로 참조할 때는 객체 자체를 참조하지만, weak으로 참조할 때는 참조 카운트를 기록하는 **사이드 테이블을 참조**하고 이를 통해서 간접적으로 객체를 참조합니다.

**💁🏻‍♂️💁🏻‍♂️ 위험한거 같은데 unowned을 사용하는 이유가 뭘까요?**

1. unowned는 객체를 참조 하지만, weak은 사이드 테이블을 참조합니다.
2. 사이드 테이블은 처음부터 존재하는 것이 아니라 weak reference로 참조될 때 생성됩니다.
3. 사이드 테이블을 생성하고 참조하는것은 그렇지 않을때 보다 오버헤드를 발생시킬 수 있습니다.
4. 그래서 참조하는 인스턴스가 메모리에 존재하는 것이 확실한 경우에는 unowned를 사용하는 것이 성능 향상에 도움이 될 수 있습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a90e959d-a91c-47dc-a274-ae60b2115ed3/Untitled.png)

**💁🏻‍♂️💁🏻‍♂️ strong, weak, unowned reference는 각각 언제 사용할까요?**

1. 기본적으로 **단방향으로 참조**가 이뤄지는 경우에는 strong도 안전하기 때문에 인스턴스가 반드시 메모리에 존재해야 하는 경우에는 strong을 사용해야 합니다.
2. weak은 강한 순환 참조 문제가 생길 수 있을 때 사용할 수 있습니다.
3. unowned는 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실한 상황에서만 사용해야 합니다.
- [https://sihyungyou.github.io/iOS-side-table/](https://sihyungyou.github.io/iOS-side-table/)

### 💁🏻‍♂️ 7-3 : class가 메모리에서 해제되는 과정을 설명해보세요

1. class 인스턴스는 strong, weak, unowned 세가지 방식을 통해 참조 될 수 있으며, 각각은 각자의 reference counting을 합니다.
2. 만약 weak count가 증가하는 경우에는 사이드 테이블을 생성하여 weak reference는 사이드 테이블을 참조합니다.
3. 인스턴스의 RC값인 strong reference count 값이 0이 되면 **deinited** 됩니다.
4. deinited되면 unowned count값이 감소하고 unowned count값이 0이 되면 **메모리에서 해제**됩니다.
5. 만약 weak count값이 0이 아니라면 사이드 테이블이 남아있는 **freed** 상태가 되며 이때 weak count값이 감소하고 weak count값이 0이 되면, 해당 오브젝트의 side table이 해제되며 객체가 완전히 소멸됩니다.

> ### 💁🏻‍♂️ 7-3 : COW에 대해서 설명해 주세요
> **💁🏻‍♂️💁🏻‍♂️ COW를 지원하지 않는 value type에서 COW를 사용하고 싶으면 어떻게 구현해야 할까요?**


## 프로토콜
> ### 프로토콜이란 무엇인지 설명하시오.
> ### Codable에 대하여 설명하시오.
> ### Hashable 프로토콜에 대해서 설명해보세요. 
> ### Hashable 프로토콜을 채택하는 커스텀 타입이 Equtable도 채택해야하는 이유가 무엇인가요?
> ### Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.
> ### 열거형도 Hashable을 채택했을 때 자동으로 Hashable하게 만들 수 있나요?
> ### Codable과 NSCoding의 차이는?
> ### associatedType이 무엇인지 설명해주세요.


## 키워드
> ### mutating 키워드에 대해 설명하시오.
> ### lazy 에 대해 설명하시오.
> ### some 키워드에 대해 설명하시오.
> ### typealias 가 무엇인지 말해주세요.
> ### required 키워드에 대해서 설명해보세요. 

## 패러다임
> ### Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.
> ### 고차함수 중 flatMap과 compactMap의 차이를 설명해보세요.
> ### Protocol Oriented Programming과 Object Oriented Programming의 차이점을 설명하시오.

## function / method
> ### instance 메서드와 class 메서드의 차이점을 설명하시오.
> ### class 메서드와 static 메서드의 차이점을 설명하시오.
> ### function과 method의 차이를 말해보세요. 
> ### inout은 언제 사용하면 좋을까요?
> ### defer란 무엇인지 설명하시오.
> ### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.

## 프로퍼티
> ### 연산 프로퍼티와 클로저를 가지는 저장 프로퍼티의 차이를 설명해보세요. 
> ### property wrapper에 대해서 설명하시오.
> ### Swift Property 종류에 대해 설명해주세요

***

### Subscripts에 대해 설명하시오.
### String은 왜 subscript로 접근이 안되는지 설명하시오. 


### Generic이 무엇이고 어떻게 동작하는지 설명해주세요.



### Generic에 대해 설명하시오.

### Result타입에 대해 설명하시오.



### 스위프트에서 추상 클래스를 만들려면 어떻게 해야할까요? 



### Subscription에 대해서 설명해주세요.




### Self와 self의 차이가 뭘까요?

### @objc는 언제 사용하나요?



### autoclosure attribute에 대해서 설명해보세요. 

### Never 반환 타입에 대해 설명해보세요.

